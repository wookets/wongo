//@ sourceMappingURL=populate.map
// Generated by CoffeeScript 1.6.1
(function() {
  var async, crud, findPopReference, runPopulateQueries, _;

  _ = require('underscore');

  async = require('async');

  crud = require(__dirname + '/../crud');

  module.exports = function(query, schema, documents, callback) {
    if (!query.populate) {
      return callback();
    }
    return runPopulateQueries(schema.fields, query.populate, documents, callback);
  };

  runPopulateQueries = function(schema, populate, docs, callback) {
    if (_.isString(populate)) {
      populate = [populate];
    }
    return async.forEach(populate, function(pop, nextInLoop) {
      var doc, pop_prop, pop_type, prop, val, _i, _ids, _len, _ref;
      pop_type = null;
      pop_prop = null;
      _ref = schema || {};
      for (prop in _ref) {
        val = _ref[prop];
        if (_.isArray(val)) {
          if (val[0].populateAlias === pop) {
            pop_type = val[0].ref;
            pop_prop = prop;
          }
        } else {
          if (val.populateAlias === pop) {
            pop_type = val.ref;
            pop_prop = prop;
          }
        }
      }
      if (!pop_type) {
        throw new Error('Populate property ' + pop + ' could not be found on schema.');
      }
      _ids = [];
      for (_i = 0, _len = docs.length; _i < _len; _i++) {
        doc = docs[_i];
        if (_.isArray(doc[pop_prop])) {
          _ids = _.union(doc[pop_prop], _ids);
        } else {
          _ids.push(doc[pop_prop]);
        }
      }
      return crud.find(pop_type, {
        where: {
          _id: {
            $in: _ids
          }
        }
      }, function(err, pop_docs) {
        var i, item, pop_doc, _j, _k, _l, _len1, _len2, _len3, _ref1, _ref2;
        if (err) {
          return nextInLoop(err);
        }
        for (_j = 0, _len1 = docs.length; _j < _len1; _j++) {
          doc = docs[_j];
          for (_k = 0, _len2 = pop_docs.length; _k < _len2; _k++) {
            pop_doc = pop_docs[_k];
            if (_.isArray(doc[pop_prop])) {
              _ref1 = doc[pop_prop];
              for (i = _l = 0, _len3 = _ref1.length; _l < _len3; i = ++_l) {
                item = _ref1[i];
                if (pop_doc._id === item) {
                  if ((_ref2 = doc[pop]) == null) {
                    doc[pop] = [];
                  }
                  doc[pop][i] = pop_doc;
                }
              }
            } else {
              if (String(pop_doc._id) === String(doc[pop_prop])) {
                doc[pop] = pop_doc;
              }
            }
          }
        }
        return nextInLoop();
      });
    }, function(err) {
      return callback(err, docs);
    });
  };

  findPopReference = function(pop, schema) {
    var prop, val, _i, _len, _ref;
    _ref = schema || {};
    for (val = _i = 0, _len = _ref.length; _i < _len; val = ++_i) {
      prop = _ref[val];
      if (_.isArray(val)) {
        if (val[0].populateAlias === pop) {
          return val[0].ref;
        }
      } else {
        if (val.populateAlias === pop) {
          return val.ref;
        }
      }
    }
  };

}).call(this);
