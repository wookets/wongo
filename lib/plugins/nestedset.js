//@ sourceMappingURL=nestedset.map
// Generated by CoffeeScript 1.6.1
(function() {
  var async, wongo;

  async = require('async');

  wongo = require(__dirname + '/../wongo');

  module.exports = function(schema, options) {
    var ns, _ref;
    if (options == null) {
      options = {};
    }
    schema.fields.lft = {
      type: Number
    };
    schema.fields.rgt = {
      type: Number
    };
    schema.fields.parentId = {
      type: String
    };
    if ((_ref = schema.indexes) == null) {
      schema.indexes = [];
    }
    schema.indexes.push({
      parentId: 1
    });
    schema.indexes.push({
      lft: 1
    });
    schema.indexes.push({
      rgt: 1
    });
    ns = {};
    ns.setRoot = function(_type, root, callback) {
      return async.waterfall([
        function(next) {
          root.parentId = null;
          root.lft = 1;
          root.rgt = 2;
          return wongo.save(_type, root, next);
        }, function(rootDoc, next) {
          var collection, values, where;
          where = {
            lft: {
              $gt: 2
            }
          };
          values = {
            $unset: {
              lft: null,
              rgt: null
            }
          };
          collection = wongo.collection(_type);
          return collection.update(where, values, {
            multi: true
          }, function(err) {
            return next(err, rootDoc);
          });
        }
      ], function(err, rootDoc) {
        return callback(err, rootDoc);
      });
    };
    ns.addNode = function(_type, node, parentId, callback) {
      return wongo.findById(_type, parentId, function(err, parent) {
        if (err) {
          return callback(err);
        }
        node.parentId = parentId;
        node.lft = parent.rgt;
        node.rgt = node.lft + 1;
        return async.parallel([
          function(done) {
            return wongo.save(_type, node, done);
          }, function(done) {
            var collection, values, where;
            where = {
              lft: {
                $gt: node.lft
              }
            };
            values = {
              $inc: {
                lft: 2,
                rgt: 2
              }
            };
            collection = wongo.collection(_type);
            return collection.update(where, values, {
              multi: true
            }, done);
          }, function(done) {
            var collection, values, where;
            where = {
              lft: {
                $lt: node.lft
              },
              rgt: {
                $gte: node.lft
              }
            };
            values = {
              $inc: {
                rgt: 2
              }
            };
            collection = wongo.collection(_type);
            return collection.update(where, values, {
              multi: true
            }, done);
          }
        ], function(err) {
          return callback(err, node);
        });
      });
    };
    ns.removeNode = function(_type, nodeId, callback) {
      return wongo.findById(_type, nodeId, function(err, node) {
        if (err) {
          return callback(err);
        }
        if (!node.lft || !node.rgt) {
          return callback(new Error('Can not remove a node not in the nested set.'));
        }
        if (node.lft + 1 !== node.rgt) {
          return callback(new Error('Can not remove a node that has children.'));
        }
        return async.parallel([
          function(done) {
            var collection, values, where;
            where = {
              lft: {
                $gt: node.lft
              }
            };
            values = {
              $inc: {
                lft: -2,
                rgt: -2
              }
            };
            collection = wongo.collection(_type);
            return collection.update(where, values, {
              multi: true
            }, done);
          }, function(done) {
            var collection, values, where;
            where = {
              lft: {
                $lt: node.lft
              },
              rgt: {
                $gt: node.lft
              }
            };
            values = {
              $inc: {
                rgt: -2
              }
            };
            collection = wongo.collection(_type);
            return collection.update(where, values, {
              multi: true
            }, done);
          }, function(done) {
            node.lft = void 0;
            node.rgt = void 0;
            node.parentId = void 0;
            return wongo.save(_type, node, done);
          }
        ], function(err) {
          return callback(err);
        });
      });
    };
    ns.findAncestors = function(_type, nodeId, callback) {
      return wongo.findById(_type, nodeId, function(err, node) {
        var query;
        if (err) {
          return callback(err);
        }
        query = {
          where: {
            lft: {
              $lt: node.lft
            },
            rgt: {
              $gt: node.rgt
            }
          }
        };
        return wongo.find(_type, query, callback);
      });
    };
    ns.findDescendants = function(_type, nodeId, callback) {
      return wongo.findById(_type, nodeId, function(err, node) {
        var query;
        if (err) {
          return callback(err);
        }
        query = {
          where: {
            lft: {
              $gt: node.lft
            },
            rgt: {
              $lt: node.rgt
            }
          }
        };
        return wongo.find(_type, query, callback);
      });
    };
    ns.findChildren = function(_type, nodeId, callback) {
      var query;
      query = {
        where: {
          parentId: nodeId
        }
      };
      return wongo.find(_type, query, callback);
    };
    wongo.ns = ns;
  };

}).call(this);
