// Generated by CoffeeScript 1.4.0
(function() {
  var async, count, create, find, findById, findOne, mongoose, normalize_populate, remove, removeAll, run_populate_queries, save, saveAll, update, update_properties, _,
    __hasProp = {}.hasOwnProperty;

  _ = require('underscore');

  async = require('async');

  mongoose = require('mongoose');

  exports.mongoose = mongoose;

  exports.ObjectId = mongoose.Schema.ObjectId;

  exports.connect = function(url) {
    return mongoose.connect(url);
  };

  exports.schema = function(_type, wschema) {
    var Schema, name, plugin, _ref, _ref1, _ref2, _ref3;
    wschema.fields._type = {
      type: String,
      "default": _type,
      required: true
    };
    Schema = new mongoose.Schema(wschema.fields);
    Schema.statics.beforeSave = (_ref = wschema.hooks) != null ? _ref.beforeSave : void 0;
    Schema.statics.afterSave = (_ref1 = wschema.hooks) != null ? _ref1.afterSave : void 0;
    _ref3 = (_ref2 = wschema.plugins) != null ? _ref2 : {};
    for (name in _ref3) {
      if (!__hasProp.call(_ref3, name)) continue;
      plugin = _ref3[name];
      if (_.isArray(plugin)) {
        Schema.plugin(plugin[0], plugin[1]);
      } else {
        Schema.plugin(plugin);
      }
    }
    return mongoose.model(_type, Schema);
  };

  exports.find = find = function(_type, query, callback) {
    var Type, mq;
    Type = mongoose.model(_type);
    mq = Type.find(query.where, query.select, {
      sort: query.sort,
      limit: query.limit,
      skip: query.skip
    });
    mq.lean();
    return mq.exec(function(err, docs) {
      if (query.populate) {
        return run_populate_queries(Type, query.populate, docs, callback);
      } else {
        return callback(err, docs);
      }
    });
  };

  exports.findOne = findOne = function(_type, query, callback) {
    if (query == null) {
      query = {};
    }
    query.limit = 1;
    return find(_type, query, function(err, result) {
      if (!err && result) {
        result = result[0];
      }
      return callback(err, result);
    });
  };

  exports.findById = findById = function(_type, _id, callback) {
    return findOne(_type, {
      where: {
        _id: _id
      }
    }, callback);
  };

  exports.count = count = function(_type, where, callback) {
    var Type;
    Type = mongoose.model(_type);
    return Type.count(where, function(err, num) {
      return callback(err, num);
    });
  };

  exports.save = save = function(_type, document, callback) {
    var Type, saved_document;
    Type = mongoose.model(_type);
    normalize_populate(Type, document);
    saved_document = null;
    return async.series([
      function(next) {
        if (!Type.beforeSave) {
          return next();
        }
        return Type.beforeSave(document, next);
      }, function(next) {
        if (document._id) {
          return Type.findById(document._id, function(err, doc) {
            if (err) {
              return callback(err);
            }
            update_properties(doc, document);
            return doc.save(function(err) {
              saved_document = doc != null ? doc.toObject({
                getters: true
              }) : void 0;
              return next(err);
            });
          });
        } else {
          return Type.create(document, function(err, doc) {
            saved_document = doc != null ? doc.toObject({
              getters: true
            }) : void 0;
            return next(err);
          });
        }
      }, function(next) {
        if (!Type.afterSave) {
          return next();
        }
        return Type.afterSave(saved_document, next);
      }
    ], function(err) {
      return callback(err, saved_document);
    });
  };

  exports.saveAll = saveAll = function(_type, documents, callback) {
    var saved_docs;
    saved_docs = [];
    return async.forEach(documents, function(document, nextInLoop) {
      return save(_type, document, function(err, doc) {
        saved_docs.push(doc);
        return nextInLoop(err);
      });
    }, function(err) {
      return callback(err, saved_docs);
    });
  };

  exports.create = create = function(_type, document, callback) {
    var Type, saved_document;
    Type = mongoose.model(_type);
    normalize_populate(Type, document);
    saved_document = null;
    return async.series([
      function(next) {
        if (!Type.beforeCreate) {
          return next();
        }
        return Type.beforeCreate(document, next);
      }, function(next) {
        return Type.create(document, function(err, doc) {
          saved_document = doc != null ? doc.toObject({
            getters: true
          }) : void 0;
          return next(err);
        });
      }, function(next) {
        if (!Type.afterCreate) {
          return next();
        }
        return Type.afterCreate(saved_document, next);
      }
    ], function(err) {
      return callback(err);
    });
  };

  exports.update = update = function(_type, where, partial_document, callback) {
    var Type;
    Type = mongoose.model(_type);
    normalize_populate(Type, partial_document);
    return Type.update(where, partial_document, {
      multi: true
    }, callback);
  };

  exports.remove = remove = function(_type, _id, callback) {
    var Type;
    Type = mongoose.model(_type);
    return async.series([
      function(next) {
        if (!Type.beforeRemove) {
          return next();
        }
        return Type.beforeRemove(_id, next);
      }, function(next) {
        return Type.findByIdAndRemove(_id, next);
      }, function(next) {
        if (!Type.afterRemove) {
          return next();
        }
        return Type.afterRemove(_id, next);
      }
    ], function(err) {
      return callback(err);
    });
  };

  exports.removeAll = removeAll = function(_type, _ids, callback) {
    return async.forEach(_ids, function(_id, nextInLoop) {
      return remove(_type, _id, nextInLoop);
    }, callback);
  };

  exports.clear = function(_type, callback) {
    var Type;
    Type = mongoose.model(_type);
    return Type.remove({}, callback);
  };

  normalize_populate = function(Type, document) {
    var i, item, key, value, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _results;
    _results = [];
    for (key in document) {
      if (!__hasProp.call(document, key)) continue;
      value = document[key];
      if ((_ref = Type.schema.path(key)) != null ? (_ref1 = _ref.options) != null ? _ref1.ref : void 0 : void 0) {
        if (_.isObject(value) && value._id) {
          _results.push(document[key] = value._id);
        } else {
          _results.push(void 0);
        }
      } else if ((_ref2 = Type.schema.path(key)) != null ? (_ref3 = _ref2.options) != null ? (_ref4 = _ref3.type) != null ? (_ref5 = _ref4[0]) != null ? _ref5.ref : void 0 : void 0 : void 0 : void 0) {
        _results.push((function() {
          var _i, _len, _results1;
          _results1 = [];
          for (i = _i = 0, _len = value.length; _i < _len; i = ++_i) {
            item = value[i];
            if (_.isObject(item) && item._id) {
              _results1.push(document[key][i] = item._id);
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        })());
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  run_populate_queries = function(Type, populate, docs, callback) {
    if (_.isString(populate)) {
      populate = [populate];
    }
    return async.forEach(populate, function(prop, nextInLoop) {
      var doc, pop_type, _i, _ids, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      pop_type = (_ref = Type.schema.path(prop)) != null ? (_ref1 = _ref.options) != null ? _ref1.ref : void 0 : void 0;
      if (pop_type == null) {
        pop_type = (_ref2 = Type.schema.path(prop)) != null ? (_ref3 = _ref2.options) != null ? (_ref4 = _ref3.type) != null ? (_ref5 = _ref4[0]) != null ? _ref5.ref : void 0 : void 0 : void 0 : void 0;
      }
      _ids = [];
      for (_i = 0, _len = docs.length; _i < _len; _i++) {
        doc = docs[_i];
        if (_.isArray(doc[prop])) {
          _ids = _.union(doc[prop], _ids);
        } else {
          _ids.push(doc[prop]);
        }
      }
      return find(pop_type, {
        where: {
          _id: {
            $in: _ids
          }
        }
      }, function(err, pop_docs) {
        var i, item, pop_doc, _j, _k, _l, _len1, _len2, _len3, _ref6;
        if (err) {
          return nextInLoop(err);
        }
        for (_j = 0, _len1 = docs.length; _j < _len1; _j++) {
          doc = docs[_j];
          for (_k = 0, _len2 = pop_docs.length; _k < _len2; _k++) {
            pop_doc = pop_docs[_k];
            if (_.isArray(doc[prop])) {
              _ref6 = doc[prop];
              for (i = _l = 0, _len3 = _ref6.length; _l < _len3; i = ++_l) {
                item = _ref6[i];
                if (String(pop_doc._id) === String(item)) {
                  doc[prop][i] = pop_doc;
                }
              }
            } else {
              if (String(pop_doc._id) === String(doc[prop])) {
                doc[prop] = pop_doc;
              }
            }
          }
        }
        return nextInLoop();
      });
    }, function(err) {
      return callback(err, docs);
    });
  };

  update_properties = function(doc, updates) {
    var prop, val;
    for (prop in updates) {
      if (!__hasProp.call(updates, prop)) continue;
      val = updates[prop];
      if (prop === '_id') {
        continue;
      }
      if (_.isArray(val)) {
        doc.markModified(prop);
      } else if (_.isObject(val)) {
        return update_properties(doc[prop], val);
      }
      if (val === null) {
        doc[prop] = void 0;
      } else {
        doc[prop] = val;
      }
    }
  };

}).call(this);
