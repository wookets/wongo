// Generated by CoffeeScript 1.4.0
(function() {
  var Schema, async, create, find, findById, findOne, mongoose, normalize_populate, update, _,
    __hasProp = {}.hasOwnProperty;

  mongoose = require('mongoose');

  async = require('async');

  _ = require('underscore');

  /*
  # Easy access mongoose pass thru
  */


  exports.Schema = Schema = mongoose.Schema;

  /*
  # Return a list of documents based on query parameters.
  # @return (err, docs)
  */


  exports.find = find = function(_type, query, callback) {
    var Type, mq;
    Type = mongoose.model(_type);
    mq = Type.find(query.where, query.select, {
      sort: query.sort,
      limit: query.limit,
      skip: query.skip
    });
    mq.lean();
    return mq.exec(function(err, docs) {
      return callback(err, docs);
    });
  };

  /*
  # Return a single document based on query paramters.
  # @return (err, doc)
  */


  exports.findOne = findOne = function(_type, query, callback) {
    if (query == null) {
      query = {};
    }
    query.limit = 1;
    return find(_type, query, function(err, result) {
      if (!err && result) {
        result = result[0];
      }
      return callback(err, result);
    });
  };

  /*
  # Return a single document based on the unique _id.
  # @return (err, doc)
  */


  exports.findById = findById = function(_type, _id, callback) {
    return findOne(_type, {
      where: {
        _id: _id
      }
    }, callback);
  };

  /*
  # This will create or update a document.
  # @param _type The name of the collection.
  # @param
  # @return (err, doc)
  */


  exports.save = function(_type, document, callback) {
    var Type;
    Type = mongoose.model(_type);
    if (document._id) {
      return update(_type, {
        _id: document._id
      }, document, function(err) {
        if (err) {
          return callback(err);
        }
        return findById(_type, document._id, callback);
      });
    } else {
      return create(_type, document, callback);
    }
  };

  exports.create = create = function(_type, document, callback) {
    var Type;
    Type = mongoose.model(_type);
    normalize_populate(Type, document);
    return Type.create(document, function(err, doc) {
      return callback(err, doc != null ? doc.toObject({
        getters: true
      }) : void 0);
    });
  };

  /*
  # This will update ALL matching documents if you are not careful.
  # @return (err)
  */


  exports.update = update = function(_type, where, partial_document, callback) {
    var Type;
    Type = mongoose.model(_type);
    normalize_populate(Type, partial_document);
    return Type.update(where, partial_document, {
      multi: true
    }, callback);
  };

  /*
  # This will nuke the entire collection' - this method is mainly for supporting test cases
  # @return (err)
  */


  exports.clear = function(_type, callback) {
    var Type;
    Type = mongoose.model(_type);
    return Type.remove({}, callback);
  };

  normalize_populate = function(Type, document) {
    var item, key, value, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _results;
    _results = [];
    for (key in document) {
      if (!__hasProp.call(document, key)) continue;
      value = document[key];
      if ((_ref = Type.schema.path(key)) != null ? (_ref1 = _ref.options) != null ? _ref1.ref : void 0 : void 0) {
        if (_.isObject(value) && value._id) {
          _results.push(document[key] = value._id);
        } else {
          _results.push(void 0);
        }
      } else if ((_ref2 = Type.schema.path(key)) != null ? (_ref3 = _ref2.options) != null ? (_ref4 = _ref3.type) != null ? (_ref5 = _ref4[0]) != null ? _ref5.ref : void 0 : void 0 : void 0 : void 0) {
        _results.push((function() {
          var _i, _len, _results1;
          _results1 = [];
          for (_i = 0, _len = value.length; _i < _len; _i++) {
            item = value[_i];
            if (_.isObject(item) && item._id) {
              _results1.push(document[key] = item._id);
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        })());
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

}).call(this);
