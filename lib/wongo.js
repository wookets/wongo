// Generated by CoffeeScript 1.4.0
(function() {
  var async, convert_ids_to_string, count, find, findById, findOne, mongoose, normalize_populate, remove, removeAll, run_populate_queries, save, saveAll, update, update_properties, _,
    __hasProp = {}.hasOwnProperty;

  _ = require('underscore');

  async = require('async');

  mongoose = require('mongoose');

  exports.mongoose = mongoose;

  exports.connect = function(url) {
    return mongoose.connect(url);
  };

  exports.schema = function(_type, wschema) {
    var Schema, index, key, option, plugin, prop, value, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
    if ((_ref = wschema.options) != null ? _ref._type : void 0) {
      wschema.fields._type = {
        type: String,
        "default": _type,
        required: true
      };
      delete wschema.options._type;
    }
    Schema = new mongoose.Schema(wschema.fields);
    _ref2 = (_ref1 = wschema.hooks) != null ? _ref1 : {};
    for (prop in _ref2) {
      if (!__hasProp.call(_ref2, prop)) continue;
      key = _ref2[prop];
      Schema.statics[prop] = wschema.hooks[prop];
    }
    _ref4 = (_ref3 = wschema.plugins) != null ? _ref3 : [];
    for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
      plugin = _ref4[_i];
      if (_.isArray(plugin)) {
        Schema.plugin(plugin[0], plugin[1]);
      } else {
        Schema.plugin(plugin);
      }
    }
    _ref6 = (_ref5 = wschema.indexes) != null ? _ref5 : [];
    for (_j = 0, _len1 = _ref6.length; _j < _len1; _j++) {
      index = _ref6[_j];
      if (_.isArray(index)) {
        Schema.index(index[0], index[1]);
      } else {
        Schema.index(index);
      }
    }
    _ref8 = (_ref7 = wschema.options) != null ? _ref7 : {};
    for (option in _ref8) {
      if (!__hasProp.call(_ref8, option)) continue;
      value = _ref8[option];
      Schema.set(option, value);
    }
    return mongoose.model(_type, Schema);
  };

  exports.find = find = function(_type, query, callback) {
    var Type;
    Type = mongoose.model(_type);
    return async.waterfall([
      function(next) {
        if (Type.beforeFind) {
          return Type.beforeFind(query, next);
        } else {
          return next();
        }
      }, function(next) {
        var mq;
        mq = Type.find(query.where, query.select, {
          sort: query.sort,
          limit: query.limit,
          skip: query.skip
        });
        mq.lean();
        return mq.exec(function(err, docs) {
          var doc, _i, _len;
          if (err) {
            return callback(err);
          }
          for (_i = 0, _len = docs.length; _i < _len; _i++) {
            doc = docs[_i];
            convert_ids_to_string(doc);
          }
          if (query.populate) {
            return run_populate_queries(Type, query.populate, docs, next);
          }
          return next(err, docs);
        });
      }, function(docs, next) {
        if (Type.afterFind) {
          return Type.afterFind(docs, function(err, docs) {
            return next(err, docs);
          });
        } else {
          return next(null, docs);
        }
      }
    ], function(err, docs) {
      return callback(err, docs);
    });
  };

  exports.findOne = findOne = function(_type, query, callback) {
    if (query == null) {
      query = {};
    }
    query.limit = 1;
    return find(_type, query, function(err, result) {
      if (!err && result) {
        result = result[0];
      }
      return callback(err, result);
    });
  };

  exports.findById = findById = function(_type, _id, callback) {
    return findOne(_type, {
      where: {
        _id: _id
      }
    }, callback);
  };

  exports.count = count = function(_type, where, callback) {
    var Type;
    Type = mongoose.model(_type);
    return Type.count(where, callback);
  };

  exports.save = save = function(_type, document, callback) {
    var Type, _ref;
    Type = mongoose.model(_type);
    if ((_ref = document._type) == null) {
      document._type = _type;
    }
    normalize_populate(Type, document);
    return async.waterfall([
      function(next) {
        if (Type.beforeSave) {
          return Type.beforeSave(document, next);
        } else {
          return next();
        }
      }, function(next) {
        if (document._id) {
          return Type.findById(document._id, function(err, doc) {
            if (err) {
              return callback(err);
            }
            update_properties(doc, document);
            return doc.save(function(err) {
              var saved_document;
              saved_document = doc != null ? doc.toObject({
                getters: true
              }) : void 0;
              convert_ids_to_string(saved_document);
              return next(err, saved_document);
            });
          });
        } else {
          return Type.create(document, function(err, doc) {
            var saved_document;
            saved_document = doc != null ? doc.toObject({
              getters: true
            }) : void 0;
            convert_ids_to_string(saved_document);
            return next(err, saved_document);
          });
        }
      }, function(saved_document, next) {
        if (Type.afterSave) {
          return Type.afterSave(saved_document, function(err) {
            return next(err, saved_document);
          });
        } else {
          return next(null, saved_document);
        }
      }
    ], function(err, saved_document) {
      return callback(err, saved_document);
    });
  };

  exports.saveAll = saveAll = function(_type, documents, callback) {
    var saved_docs;
    saved_docs = [];
    return async.forEach(documents, function(document, nextInLoop) {
      return save(_type, document, function(err, doc) {
        saved_docs.push(doc);
        return nextInLoop(err);
      });
    }, function(err) {
      return callback(err, saved_docs);
    });
  };

  exports.update = update = function(_type, where, partial_document, callback) {
    var Type;
    Type = mongoose.model(_type);
    normalize_populate(Type, partial_document);
    return Type.update(where, partial_document, {
      multi: true
    }, callback);
  };

  exports.remove = remove = function(_type, _id, callback) {
    var Type;
    Type = mongoose.model(_type);
    return async.series([
      function(next) {
        if (Type.beforeRemove) {
          return Type.beforeRemove(_id, next);
        } else {
          return next();
        }
      }, function(next) {
        return Type.findByIdAndRemove(_id, next);
      }, function(next) {
        if (Type.afterRemove) {
          return Type.afterRemove(_id, next);
        } else {
          return next();
        }
      }
    ], function(err) {
      return callback(err);
    });
  };

  exports.removeAll = removeAll = function(_type, _ids, callback) {
    return async.forEach(_ids, function(_id, nextInLoop) {
      return remove(_type, _id, nextInLoop);
    }, callback);
  };

  exports.clear = function(_type, callback) {
    var Type;
    Type = mongoose.model(_type);
    return Type.remove({}, callback);
  };

  normalize_populate = function(Type, document) {
    var i, item, prop, val, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _results;
    _results = [];
    for (prop in document) {
      if (!__hasProp.call(document, prop)) continue;
      val = document[prop];
      if ((_ref = Type.schema.path(prop)) != null ? (_ref1 = _ref.options) != null ? _ref1.ref : void 0 : void 0) {
        if (val != null ? val._id : void 0) {
          _results.push(document[prop] = val._id);
        } else {
          _results.push(void 0);
        }
      } else if ((_ref2 = Type.schema.path(prop)) != null ? (_ref3 = _ref2.options) != null ? (_ref4 = _ref3.type) != null ? (_ref5 = _ref4[0]) != null ? _ref5.ref : void 0 : void 0 : void 0 : void 0) {
        _results.push((function() {
          var _i, _len, _results1;
          _results1 = [];
          for (i = _i = 0, _len = val.length; _i < _len; i = ++_i) {
            item = val[i];
            if (item != null ? item._id : void 0) {
              _results1.push(document[prop][i] = item._id);
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        })());
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  run_populate_queries = function(Type, populate, docs, callback) {
    if (_.isString(populate)) {
      populate = [populate];
    }
    return async.forEach(populate, function(prop, nextInLoop) {
      var doc, pop_type, _i, _ids, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      pop_type = (_ref = Type.schema.path(prop)) != null ? (_ref1 = _ref.options) != null ? _ref1.ref : void 0 : void 0;
      if (pop_type == null) {
        pop_type = (_ref2 = Type.schema.path(prop)) != null ? (_ref3 = _ref2.options) != null ? (_ref4 = _ref3.type) != null ? (_ref5 = _ref4[0]) != null ? _ref5.ref : void 0 : void 0 : void 0 : void 0;
      }
      if (!pop_type) {
        throw new Error('Populate property ' + prop + ' could not be found on schema.');
      }
      _ids = [];
      for (_i = 0, _len = docs.length; _i < _len; _i++) {
        doc = docs[_i];
        if (_.isArray(doc[prop])) {
          _ids = _.union(doc[prop], _ids);
        } else {
          _ids.push(doc[prop]);
        }
      }
      return find(pop_type, {
        where: {
          _id: {
            $in: _ids
          }
        }
      }, function(err, pop_docs) {
        var i, item, pop_doc, _j, _k, _l, _len1, _len2, _len3, _ref6;
        if (err) {
          return nextInLoop(err);
        }
        for (_j = 0, _len1 = docs.length; _j < _len1; _j++) {
          doc = docs[_j];
          for (_k = 0, _len2 = pop_docs.length; _k < _len2; _k++) {
            pop_doc = pop_docs[_k];
            if (_.isArray(doc[prop])) {
              _ref6 = doc[prop];
              for (i = _l = 0, _len3 = _ref6.length; _l < _len3; i = ++_l) {
                item = _ref6[i];
                if (String(pop_doc._id) === String(item)) {
                  doc[prop][i] = pop_doc;
                }
              }
            } else {
              if (String(pop_doc._id) === String(doc[prop])) {
                doc[prop] = pop_doc;
              }
            }
          }
        }
        return nextInLoop();
      });
    }, function(err) {
      return callback(err, docs);
    });
  };

  update_properties = function(doc, updates) {
    var prop, val;
    for (prop in updates) {
      if (!__hasProp.call(updates, prop)) continue;
      val = updates[prop];
      if (prop === '_id' || prop === 'id' || prop === '_bsontype') {
        continue;
      } else if (_.isNull(val)) {
        doc[prop] = void 0;
      } else if (_.isFunction(val) || _.isString(val) || _.isNumber(val) || _.isDate(val) || _.isBoolean(val) || _.isUndefined(val)) {
        doc[prop] = val;
      } else if (_.isArray(val)) {
        doc[prop] = val;
        doc.markModified(prop);
      } else if (_.isObject(val)) {
        return update_properties(doc[prop], val);
      }
    }
  };

  convert_ids_to_string = function(doc) {
    var item, prop, val;
    if (doc instanceof mongoose.Types.ObjectId) {
      return String(doc);
    }
    if (_.isFunction(doc) || _.isString(doc) || _.isNumber(doc) || _.isEmpty(doc) || _.isDate(doc) || _.isUndefined(doc) || _.isBoolean(doc) || _.isNull(val)) {
      return doc;
    }
    if (_.isArray(doc)) {
      return (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = doc.length; _i < _len; _i++) {
          item = doc[_i];
          _results.push(convert_ids_to_string(item));
        }
        return _results;
      })();
    }
    if (_.isObject(doc)) {
      for (prop in doc) {
        if (!__hasProp.call(doc, prop)) continue;
        val = doc[prop];
        doc[prop] = convert_ids_to_string(val);
      }
      return doc;
    }
  };

}).call(this);
