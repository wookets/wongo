// Generated by CoffeeScript 1.6.1
(function() {
  var validateField, _,
    __hasProp = {}.hasOwnProperty;

  _ = require('underscore');

  module.exports = function(document, schema, callback) {
    var field, meta, prop, result, val, _ref;
    if (document._id) {
      for (prop in document) {
        if (!__hasProp.call(document, prop)) continue;
        val = document[prop];
        if (prop === '_id') {
          continue;
        }
        result = validateField(document, prop, schema.fields[prop]);
        if (_.isString(result)) {
          return callback(new Error(result));
        }
      }
    } else {
      _ref = schema.fields;
      for (field in _ref) {
        if (!__hasProp.call(_ref, field)) continue;
        meta = _ref[field];
        if (prop === '_id') {
          continue;
        }
        result = validateField(document, field, meta);
        if (_.isString(result)) {
          return callback(new Error(result));
        }
      }
    }
    return callback();
  };

  validateField = function(document, field, meta) {
    var item, value, _i, _len, _ref, _results;
    value = document[field];
    if (meta.required && _.isUndefined(value)) {
      return field + ' is required.';
    }
    if (_.isArray(meta)) {
      if (meta[0].required && _.isUndefined(value)) {
        return field + ' is required.';
      }
      _ref = value || [];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        _results.push(validateField(field, item, meta[0]));
      }
      return _results;
    } else {
      switch (meta.type) {
        case String:
          if (value && !_.isString(value)) {
            return field + ' needs to be a string.';
          }
          if (meta.min && (value != null ? value.length : void 0) < meta.min) {
            return field + ' needs to be at least ' + meta.min + ' characters in length.';
          }
          if (meta.max && (value != null ? value.length : void 0) > meta.max) {
            return field + ' needs to be at most ' + meta.max + ' characters in length.';
          }
          if (meta["enum"] && !_.contains(meta["enum"], value)) {
            return field + ' must be valid.';
          }
          break;
        case Number:
          if (value && !_.isNumber(value)) {
            return field + ' needs to be a number.';
          }
          if (meta.min && value < meta.min) {
            return field + ' needs to be greater than ' + meta.min + '.';
          }
          if (meta.max && value > meta.max) {
            return field + ' needs to be less than or equal to ' + meta.max + '.';
          }
          break;
        case Boolean:
          if (value && !_.isBoolean(value)) {
            return field + ' needs to be a boolean.';
          }
          break;
        case Date:
          if (value && !_.isDate(value)) {
            return field + ' needs to be a date.';
          }
      }
    }
  };

}).call(this);
