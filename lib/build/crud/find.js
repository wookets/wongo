// Generated by CoffeeScript 1.6.1
(function() {
  var ObjectID, async, convertSelectForMongo, convertWhereForMongo, modeler, mongo, mongodb, _;

  _ = require('underscore');

  async = require('async');

  mongodb = require('mongodb');

  ObjectID = mongodb.ObjectID;

  modeler = require(__dirname + '/../modeler');

  mongo = require(__dirname + '/../mongo');

  exports.find = function(_type, query, callback) {
    var documents, schema;
    schema = modeler.schema(_type);
    if (!callback || !_.isFunction(callback)) {
      throw new Error('callback required.');
    }
    if (!query || !_.isObject(query)) {
      return callback(new Error('query required.'));
    }
    if (!query.where) {
      query = {
        where: query
      };
    }
    documents = [];
    return async.series([
      function(next) {
        return mongo.ifConnected(next);
      }, function(next) {
        return async.eachSeries(schema.middleware.beforeFind, function(func, nextInLoop) {
          return func(query, schema, nextInLoop);
        }, function(err) {
          return next(err);
        });
      }, function(next) {
        var collection, options, select, where;
        where = convertWhereForMongo(query.where);
        select = convertSelectForMongo(query.select);
        options = {
          sort: query.sort,
          limit: query.limit,
          skip: query.skip
        };
        collection = mongo.collection(schema.collectionName || _type);
        return collection.find(where, select, options).toArray(function(err, result) {
          var doc, _i, _len;
          if (err) {
            return next(err, result);
          }
          for (_i = 0, _len = result.length; _i < _len; _i++) {
            doc = result[_i];
            if (doc._id) {
              doc._id = String(doc._id);
            }
          }
          documents = result;
          return next(null);
        });
      }, function(next) {
        return async.eachSeries(schema.middleware.afterFind, function(func, nextInLoop) {
          return func(query, schema, documents, nextInLoop);
        }, function(err) {
          return next(err);
        });
      }
    ], function(err) {
      return callback(err, documents);
    });
  };

  exports.findOne = function(_type, query, callback) {
    if (!query.where) {
      query = {
        where: query
      };
    }
    query.limit = 1;
    return exports.find(_type, query, function(err, result) {
      return callback(err, result != null ? result[0] : void 0);
    });
  };

  exports.findById = function(_type, _id, callback) {
    return exports.findOne(_type, {
      _id: _id
    }, callback);
  };

  exports.findByIds = function(_type, _ids, callback) {
    return exports.find(_type, {
      _id: {
        $in: _ids
      }
    }, callback);
  };

  convertWhereForMongo = function(where) {
    var _id, _ref;
    if ((_ref = where._id) != null ? _ref.$in : void 0) {
      where._id.$in = (function() {
        var _i, _len, _ref1, _results;
        _ref1 = where._id.$in;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          _id = _ref1[_i];
          _results.push(new ObjectID(_id));
        }
        return _results;
      })();
    } else if (where._id) {
      where._id = new ObjectID(where._id);
    }
    return where;
  };

  convertSelectForMongo = function(select) {
    var field, fields, selectString, _i, _len;
    if (_.isString(select)) {
      selectString = select;
      fields = select.split(' ');
      select = {};
      for (_i = 0, _len = fields.length; _i < _len; _i++) {
        field = fields[_i];
        select[field] = true;
      }
    }
    return select;
  };

}).call(this);
