//@ sourceMappingURL=modeler.map
// Generated by CoffeeScript 1.6.1
(function() {
  var applyOptions, applyPlugins, async, ensureIndexes, hooks, mongo, normalize, options, schemas, setupMiddleware, _,
    __hasProp = {}.hasOwnProperty;

  _ = require('underscore');

  async = require('async');

  hooks = require(__dirname + '/hooks');

  mongo = require(__dirname + '/mongo');

  options = require(__dirname + '/options');

  exports.schemas = schemas = {};

  exports.schema = function(_type, schema) {
    var _ref;
    if (!_type || !_.isString(_type)) {
      throw new Error('_type required.');
    }
    if (!schema) {
      if (!schemas[_type]) {
        throw new Error('_type [' + _type + '] not recognized');
      }
      return schemas[_type];
    }
    if (!schema.fields || _.isEmpty(schema.fields)) {
      throw new Error('We need to have some sort of schema or whats the point?');
    }
    schema._type = _type;
    if ((_ref = schema.collectionName) == null) {
      schema.collectionName = _type;
    }
    normalize(schema);
    applyOptions(schema);
    setupMiddleware(schema);
    applyPlugins(schema);
    ensureIndexes(_type, schema);
    schemas[_type] = schema;
    return schema;
  };

  normalize = function(schema) {
    var field, meta, _ref, _ref1, _ref2, _ref3, _ref4, _results;
    if ((_ref = schema.indexes) == null) {
      schema.indexes = [];
    }
    if ((_ref1 = schema.plugins) == null) {
      schema.plugins = [];
    }
    if ((_ref2 = schema.hooks) == null) {
      schema.hooks = {};
    }
    if ((_ref3 = schema.options) == null) {
      schema.options = {};
    }
    _ref4 = schema.fields;
    _results = [];
    for (field in _ref4) {
      if (!__hasProp.call(_ref4, field)) continue;
      meta = _ref4[field];
      if (!meta) {
        throw new Error('We were expecting ' + field + ' to have proper meta.');
      }
      if (_.isArray(meta)) {
        if (!meta[0]) {
          throw new Error('We were expecting ' + field + ' to have proper array meta.');
        }
        if (meta[0].type) {
          continue;
        }
        switch (meta[0]) {
          case String:
          case Number:
          case Boolean:
          case Date:
            _results.push(meta[0] = {
              type: meta[0]
            });
            break;
          default:
            normalize(meta[0]);
            _results.push(meta[0].type = 'SubDoc');
        }
      } else {
        if (meta.type) {
          continue;
        }
        switch (meta) {
          case String:
          case Number:
          case Boolean:
          case Date:
            _results.push(schema.fields[field] = {
              type: meta
            });
            break;
          default:
            normalize(meta);
            _results.push(meta.type = 'SubDoc');
        }
      }
    }
    return _results;
  };

  applyOptions = function(schema) {
    var _ref;
    return (_ref = schema.options) != null ? _ref : schema.options = {};
  };

  setupMiddleware = function(schema) {
    var afterFind, afterRemove, afterSave, applyDefaults, beforeFind, beforeRemove, beforeSave, generateSubdocIds, populate, prune, stringizeObjectIDAfterFind, stringizeObjectIDAfterSave, stringizeObjectIDBeforeFind, stringizeObjectIDBeforeSave, validate;
    schema.middleware = {
      beforeValidate: [],
      beforeSave: [],
      rightBeforeSave: [],
      afterSave: [],
      beforeFind: [],
      afterFind: [],
      beforeRemove: [],
      afterRemove: []
    };
    prune = schema.hooks.prune;
    if (_.isUndefined(prune)) {
      prune = options.prune;
    }
    if (prune === true) {
      prune = hooks.prune;
    }
    if (_.isFunction(prune)) {
      schema.middleware.beforeValidate.push(prune);
    }
    applyDefaults = schema.hooks.applyDefaults;
    if (_.isUndefined(applyDefaults)) {
      applyDefaults = options.applyDefaults;
    }
    if (applyDefaults === true) {
      applyDefaults = hooks.applyDefaults;
    }
    if (_.isFunction(applyDefaults)) {
      schema.middleware.beforeValidate.push(applyDefaults);
    }
    validate = schema.hooks.validate;
    if (_.isUndefined(validate)) {
      validate = options.validate;
    }
    if (validate === true) {
      validate = hooks.validate;
    }
    if (_.isFunction(validate)) {
      schema.middleware.beforeSave.push(validate);
    }
    beforeSave = schema.hooks.beforeSave;
    if (_.isUndefined(beforeSave)) {
      beforeSave = options.beforeSave;
    }
    if (_.isFunction(beforeSave)) {
      schema.middleware.beforeSave.push(beforeSave);
    }
    generateSubdocIds = schema.hooks.generateSubdocIds;
    if (_.isUndefined(generateSubdocIds)) {
      generateSubdocIds = options.generateSubdocIds;
    }
    if (generateSubdocIds === true) {
      generateSubdocIds = hooks.generateSubdocIds;
    }
    if (_.isFunction(generateSubdocIds)) {
      schema.middleware.rightBeforeSave.push(generateSubdocIds);
    }
    stringizeObjectIDBeforeSave = schema.hooks.stringizeObjectIDBeforeSave;
    if (_.isUndefined(stringizeObjectIDBeforeSave)) {
      stringizeObjectIDBeforeSave = options.stringizeObjectID;
    }
    if (stringizeObjectIDBeforeSave === true) {
      stringizeObjectIDBeforeSave = hooks.stringizeObjectIDBeforeSave;
    }
    if (_.isFunction(stringizeObjectIDBeforeSave)) {
      schema.middleware.rightBeforeSave.push(stringizeObjectIDBeforeSave);
    }
    stringizeObjectIDAfterSave = schema.hooks.stringizeObjectIDAfterSave;
    if (_.isUndefined(stringizeObjectIDAfterSave)) {
      stringizeObjectIDAfterSave = options.stringizeObjectID;
    }
    if (stringizeObjectIDAfterSave === true) {
      stringizeObjectIDAfterSave = hooks.stringizeObjectIDAfterSave;
    }
    if (_.isFunction(stringizeObjectIDAfterSave)) {
      schema.middleware.afterSave.push(stringizeObjectIDAfterSave);
    }
    afterSave = schema.hooks.afterSave;
    if (_.isUndefined(afterSave)) {
      afterSave = options.afterSave;
    }
    if (_.isFunction(afterSave)) {
      schema.middleware.afterSave.push(afterSave);
    }
    beforeFind = schema.hooks.beforeFind;
    if (_.isUndefined(beforeFind)) {
      beforeFind = options.beforeFind;
    }
    if (_.isFunction(beforeFind)) {
      schema.middleware.beforeFind.push(beforeFind);
    }
    stringizeObjectIDBeforeFind = schema.hooks.stringizeObjectIDBeforeFind;
    if (_.isUndefined(stringizeObjectIDBeforeFind)) {
      stringizeObjectIDBeforeFind = options.stringizeObjectID;
    }
    if (stringizeObjectIDBeforeFind === true) {
      stringizeObjectIDBeforeFind = hooks.stringizeObjectIDBeforeFind;
    }
    if (_.isFunction(stringizeObjectIDBeforeFind)) {
      schema.middleware.beforeFind.push(stringizeObjectIDBeforeFind);
    }
    stringizeObjectIDAfterFind = schema.hooks.stringizeObjectIDAfterFind;
    if (_.isUndefined(stringizeObjectIDAfterFind)) {
      stringizeObjectIDAfterFind = options.stringizeObjectID;
    }
    if (stringizeObjectIDAfterFind === true) {
      stringizeObjectIDAfterFind = hooks.stringizeObjectIDAfterFind;
    }
    if (_.isFunction(stringizeObjectIDAfterFind)) {
      schema.middleware.afterFind.push(stringizeObjectIDAfterFind);
    }
    populate = schema.hooks.populate;
    if (_.isUndefined(populate)) {
      populate = options.populate;
    }
    if (populate === true) {
      populate = hooks.populate;
    }
    if (_.isFunction(populate)) {
      schema.middleware.afterFind.push(populate);
    }
    afterFind = schema.hooks.afterFind;
    if (_.isUndefined(afterFind)) {
      afterFind = options.afterFind;
    }
    if (_.isFunction(afterFind)) {
      schema.middleware.afterFind.push(afterFind);
    }
    beforeRemove = schema.hooks.beforeRemove;
    if (_.isUndefined(beforeRemove)) {
      beforeRemove = options.beforeRemove;
    }
    if (_.isFunction(beforeRemove)) {
      schema.middleware.beforeRemove.push(beforeRemove);
    }
    afterRemove = schema.hooks.afterRemove;
    if (_.isUndefined(afterRemove)) {
      afterRemove = options.afterRemove;
    }
    if (_.isFunction(afterRemove)) {
      return schema.middleware.afterRemove.push(afterRemove);
    }
  };

  applyPlugins = function(schema) {
    var plugin, _i, _len, _ref, _ref1, _results;
    _ref1 = (_ref = schema.plugins) != null ? _ref : [];
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      plugin = _ref1[_i];
      if (_.isArray(plugin)) {
        _results.push(plugin[0](schema, plugin[1]));
      } else if (_.isFunction(plugin)) {
        _results.push(plugin(schema));
      } else {
        throw new Error('The plugin defined for ' + schema._type + ' is incorrectly defined (must be an array or a function).');
      }
    }
    return _results;
  };

  ensureIndexes = function(_type, schema) {
    return async.forEach(schema.indexes, function(index, nextInLoop) {
      return mongo.ifConnected(function() {
        if (_.isArray(index)) {
          mongo.db.ensureIndex(schema.collectionName, index[0], index[1], function(err) {
            if (err) {
              throw err;
            }
          });
        } else {
          mongo.db.ensureIndex(schema.collectionName, index, function(err) {
            if (err) {
              throw err;
            }
          });
        }
        return nextInLoop();
      });
    });
  };

}).call(this);
